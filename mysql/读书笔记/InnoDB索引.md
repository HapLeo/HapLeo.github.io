# InnoDB索引

```shell
索引
 - 结构
 	- B+树
 - 功能
 	- 加速查询
 - 用法
 	- 主键递增
 	- 覆盖索引
 	- 最左匹配
 	- 排序分组
 	- 函数破坏
```





## 索引是什么？

InnoDB中的索引，是一种B+树存储结构。

B+树分为叶子节点和非叶子结点，每个节点表示一个页，固定16KB大小。用户数据通过索引列排序后，存放到叶子节点的页中，而非叶子结点就像书的目录，保存子节点中最小的索引值及对应的页号。

有两种索引类型：聚簇索引（又叫：主键索引）和非聚簇索引（又叫：二级索引）。主键索引中，叶子节点保存了完整的用户记录，非叶子结点中的记录则保存每一页的最小主键及对应的页号。因此，当我们需要通过主键查询一条记录时，可以通过非叶子结点快速锁定到页号，再在页内通过页目录二分查找+单链表遍历找到指定主键对应的完整记录。二级索引与主键索引类似，只是叶子节点保存的是主键的值。



## 为什么用索引？

索引就是通过B+数层层缩小查找范围来加快查询速度的。

假如没有索引结构，我们查询数据的方法就只有从头到尾挨个查找，即**全表扫描**，查询效率非常低。

通过索引的层层定位，能加速查询，快速定位。这种快速查询本身也是基于记录的排序。



## 如何正确使用索引？

- 主键递增减少分裂：主键递增，会减少页面分裂，降低性能损耗。

- 覆盖索引避免回表：如果select子句、where子句、on子句、order by 子句和group by子句中的条件字段在索引列范围内，则不需要回表，直接在二级索引中即可完成查询。

- 联合索引最左原则：联合索引index(a,b,c)中，索引按照a排序，a相等才会按照b排序，以此类推。因此，可以通过联合索引的这一排序规则加速排序、分组，但排序、分组条件必须符合索引的按左排序规律，切升序和降序不能混用。

- 索引排序最左原则：索引本身有序，顺从索引本身的排序规则效率极佳，因此order by 子句也要符合最左原则，而且不能ASC和DESC混用。

- 索引分组最左原则：索引是按照索引列排序的，因此也是索引列分组的，顺从索引列规则分组效率极佳，否则无法用上索引进行分组。

- 使用函数破坏排序：在排序列使用函数或表达式时，无法通过索引排序。

- 查询结果越少越好：二级索引需要回表来查找完整记录，因此，如果结果集过大，则二级索引的效率甚至低于全表扫描，以致用不上索引。limit语句通常有利于使用索引。

- 不要随意创建索引：一个索引就是一个B+数，B+树中每一页都是16KB的存储空间。且每次增删改用户记录都需要消耗时间重新调节索引结构，因此，索引是有代价的。

- 建索引范式1：只为where子句、on子句、order by 子句和group by子句中的条件字段建立索引，select子句中条件通常不必作为索引列，以避免索引列过多，维护代价大。

- 建索引范式2：索引列的类型尽量小、值的区分度尽量大。索引列类型小，单个页面会存储更多索引记录，减少IO；索引列值的区分度大，能更快速地定位目标记录所在页。

- 建索引范式3：如果一个列长度很大，可以将该列前几个字符作为索引列，但此时无法支持此索引列的排序了。

  

