#### 为什么要学习JVM?
了解JVM特性和运行原理，才能写出最适合JVM运行的代码；

学习JVM的知识模块：自动内存管理、编译与优化、并发。



#### 内存管理

JVM的运行时数据区如何划分？

JVM运行时数据区分为五个部分：方法区、堆区、虚拟机栈、本地方法栈、程序计数器。其中，方法区和堆区是线程共享区域，虚拟机栈、本地方法栈、程序计数器则为线程私有区域。

**程序计数器**：线程私有，存放下一条字节码指令的行号，用于分支循环等流程控制、跳转、异常处理、线程恢复等。

**虚拟机栈**：线程私有，一个线程每调用一个方法，就会生成一个栈帧进入虚拟机栈，栈帧保存了方法的局部变量表、操作数栈、动态连接、方法出口等信息；方法调用完毕该栈帧就会出栈。

> 什么是局部变量表？局部变量表存放了编译期可知的基本数据类型的变量、对象引用和返回类型。
>
> 虚拟机栈会抛出什么异常？每个线程占用一块虚拟机栈的空间，在一个线程里，不停地调用方法，就会不停地产生栈帧并压入栈，当栈帧过多时就会抛出StackOverFlowError；如果虚拟机栈容量可以自动扩展，那么它会一直变大，直到申请不到内存了，就会抛出OutOfMemoryError.

**本地方法栈**：线程私有，与本地方法栈类似，转为native方法服务。

> Hotspot中对虚拟机栈与本地方法栈进行了合并。

**Java堆**：线程共享，唯一的目的就是存放对象实例，几乎所有对象实例都在这里分配内存。

> 通过参数 -Xmx和-Xms设定堆的最大内存和初始内存。
>
> 如果堆的内存耗尽，且无法扩展时，JVM抛出OutOfMemeryError异常；

**方法区**：线程共享，存放已经被虚拟机加载的类型信息、常亮、静态变量、即时编译器编译后的代码等。

> 方法区无法满足新的内存分配需求时，抛出OutOfMemoryError异常；

**运行时常量池**：方法区的一部分，用于存放编译期生成的各种字面量与符号引用，也可运行期间放入新的常量，常用的例子：`String.intern()`;

**直接内存**：NIO通过Channel和Buffer方式调用Native函数直接分配堆外内存以提高性能，这部分内存不受-Xmx限制，但如果本机内存不足以分配新的堆外内存，会抛出OutOfMemoryError异常。



HotSpot中对象在堆中的创建过程是怎样的？

JVM遇到一条字节码的new指令时：

1. **加载类**：先去常量池中找对应的符号引用，并检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，就进行类的加载；
2. **分配内存**：内存大小在类加载完成后即可确定。为对象分配内存有两种方式：`指针碰撞`和`空闲列表`，指针碰撞方式是指针沿着规整的内存移动与对象相等大小，适合带有压缩整理的GC；空闲列表方式是将空闲内存记录到一个列表中，为对象分配内存时到列表中找到大小最适合的内存块，这种方式适合基于清除算法的GC；

3. **初始化零值**：将分配到的内存除对象头以外全部初始化为零值，这也是Java中字段可以不赋初始值就可使用的原因。
4. **设置对象头**：对象头保存了该对象的多种信息：类型指针、哈希码、GC分代年龄、偏向锁等。
5. **执行构造函数**：执行Class文件中的`<init>()`方法,配置对象的资源和状态信息；

> 对象创建过程需要操作堆区和方法区，这两个区都是线程共享的内存区域，如何保证线程安全？
>
> 两种方法：`CAS+失败重试`和`TLAB(Thread Local Allocation Buffer)`,其中TLAB会优先使用。

对象在内存中长什么样子？

对象可划分成三个部分：对象头、实例数据、对齐填充。

**对象头（Header）**：包含两部分：Mark word和类型指针。

`Mark Word`：32位机器中占32比特，64位机器中占64比特，保存了对象的哈希码、分代年龄、锁标志等信息。

`类型指针`：保存指向该对象的类型元数据的指针。如果是数组对象，还要保存数组长度。

**实例数据（Instance Data）**：记录父类和当前类的字段内容，默认分配顺序为：longs/doubles、ints、shorts/chars、bytes/booleans、oops(Ordinary Object Pointers,OOPs)。字段分配顺序可以归结为：`宽度优先，父类优先`，即比较宽的字段在前面，相同宽度的字段父类优先。

**对齐填充（Padding）**：HotSpot要求对象起始地址必须是8字节的整数倍，因此，如果对象头和实例数据占用内存不是8字节整数倍，需要对齐填充来补全。

对象创建好后，如何找到它？

虚拟机栈里，每个线程的栈帧中都保存着一个方法的本地变量表，变量表中存放着对象引用，这些引用保存了对象的内存地址或对象的句柄的内存地址。

>  保存地址和保存句柄有什么区别？如果引用保存着对象的地址，当对象被GC移动后，需要修改引用中的地址，而如果保存对象的句柄，则GC移动后只需要修改句柄中的地址即可，引用可以保持不变。使用句柄的代价是多了一次跳转的消耗。

哪些区会抛出OutOfMemoryError（OOM）异常？什么情况会导致抛出该异常？

理论上堆区、方法区、虚拟机栈、本地方法栈都会抛出OutOfMemoryError异常，只有程序计数器不会抛出异常。

堆区：堆区保存着对象实例，堆区大小通过参数：`-Xms`和`-Xmx`分别控制着最小值和最大值。当堆内存无法为新的对象分配内存时，会抛出OOM异常；因此，诊断堆区OOM异常原因时，首先要想到是否是某个引用导致大对象无法回收形成的内存泄漏，如果不是，则需要适当调大堆区内存。

> 自JDK1.7起，运行时常量池已经从方法区迁入堆区中，例如：`String.intern()`获取的是字符串对象在堆中的引用。因此，过多的运行时常量也有可能导致OOM异常。
>
> 通过参数：`+HeapDumpOnOutOfMemoryError`可以在JVM出现内存溢出时Dump出当前内存堆转储快照以便分析。堆内存的溢出通常会在OutOfMemoryError后面跟上说明：Java heap space.

方法区：方法区用来保存类的信息，如类名、访问修饰符、常量池、字段描述、方法描述等。当方法区的空间不足以加载新的类时，就会抛出OOM异常。

> 这样的场景包括：通过动态代理、CGLib、JSP之类的模板引擎等产生大量的类；
>
> JDK1.7及之前，HotSpot中使用永久代实现方法区，通过`-XX:PermSize`和`-XX:MaxPermSize`限制永久代大小；JDK1.8及之后，HotSpot中使用元空间实现方法区，通过`-XX:MetaspaceSize`指定初始大小，`-XX:MaxMetaspaceSize`指定最大值，该值默认为-1，即不限制，只受限于本地内存大小，因此很难出现方法区OOM异常了。参数`-XX:MinMetaspaceFreeRatio`，指定一个比例，当GC之后，元空间剩余空间比例不小于这个值；参数`-XX:MaxMetaspaceFreeRatio`控制元空间最大剩余比例。

虚拟机栈和本地方法栈：在HotSpot中并不区分虚拟机栈和本地方法栈。《Java虚拟机规范》中，如果线程请求的栈深度大于虚拟机允许的栈深度，将抛出StackOverFlowError异常；如果虚拟机栈内存允许动态扩展，则扩展到无法申请到足够内存时，抛出OOM异常。而HotSpot选择不支持扩展，所以只有在创建线程分配内存时无法获得足够内存而出现OOM，否则在线程运行时是不会出现OOM的，只会因为栈容量无法容纳新的栈帧而导致StackOverFlowError异常。

> 栈的容量通过参数：`-Xss`设定。

本机直接内存溢出：典型场景是使用NIO，此时Dump出的文件很小，OOM异常后面没有任何提示。

> 直接内存容量大小通过参数：`-XX:MaxDirectMemorySize`指定，默认与堆的最大值（`-Xmx`）一致。





## 垃圾回收器及内存分配策略

如何判断一个对象是否存活？

通常两种算法：引用计数法和可达性分析算法。

引用计数法：保存每个对象的当前引用个数。缺点：对象之间互相引用的问题。

可达性分析算法：通过根对象（GC Roots）作为起始节点集，从起始节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”。如果对象与GC Roots间没有任何引用链，即不可达，则此对象无法再被使用。

什么是强引用、软引用、弱引用、虚引用？

**强引用**（Strongly Reference）：普通的引用，如Object obj = new Object();只要强引用关系还在，垃圾收集器就不会这个对象。

**软引用**（Soft Reference）: 还有用，但非必须的对象，通过SoftReference类构造软引用；只被软引用关联着的对象，在系统将要发生内存溢出之前被二次回收，如果仍没有足够内存再抛出OOM异常。

**弱引用**（Week Reference）:关联的对象只能生存到下一次GC。通过WeekReference类构造弱引用。

**虚引用**（Phantom Reference）: 不会对关联的对象的生存时间产生任何影响，也无法通过虚引用取得对象实例。虚引用的目的是能在这个对象被回收时收到一个系统通知。通过PhantomReference构造虚引用。

当一个对象通过可达性分析第一次被发现没有与GC Roots连接的引用链时，并不会被直接回收，而是将其加入队列去执行finalize()方法，然后给这个对象标记下一次不需要执行finalize()方法。第二次发现它没有与GC Roots连接的引用链时，又发现了不需要执行finalize()方法的标记，则会进行回收。

### 分代收集理论

分代收集理论基于两个分代假说：

弱分代假说：绝大多数对象都是朝生夕灭的。

强分代假说：熬过越多次垃圾收集过程的对象越难以消亡。

因此，将收集器划分出不同的年龄区域，通过不同的算法进行高效回收。

**部分收集**（Partial GC）:指目标不是完整收集整个堆得垃圾收集。

**新生代收集**（Minor GC/Young GC）:指目标只是新生代的垃圾收集.

**老年代收集**(Major GC/Old GC):指目标只是老年代的垃圾收集。有些地方的Major GC代表整堆收集；

**混合收集**(Mixed GC):指目标是收集整个新生代以及部分老年代的垃圾收集。

**整堆收集**(Full GC):收集生个Java堆和方法区的垃圾收集。



### 垃圾收集算法

**标记-清除算法（Mark-Sweep）**：先标记，再清除。带来的问题：大量的标记和清除动作导致GC效率低；空间碎片问题。

**标记-复制算法**：将内存均分为两块，当一块内存用完了，就将还存活的对象复制到另一块上面，再把已使用过的内存空间一次清理掉，适合存活对象较少的场景。带来的问题：空间利用率低。

**Appel算法**：适用于新生代的算法。把新生代分为较大的Eden区和两块较小的Survivor区（Survivor1和Survivor2），每次分配内存只使用Eden和其中一块Survivor。发生垃圾收集时，将Eden区和Survivor区中仍然存活的对象放到另一块Survivor区中，并清理掉Eden区和那块Survivor。HotSpot中，Eden区占80%空间，Survivor1和Survivor2分别占10%空间。特殊情况，当Survivor空间不足以容纳一次Minor GC存活的对象时，就需要其他的内存区域（通常是方法区）进行分配担保。

**标记-整理算法（Mark-Compact）**：适用于老年代的算法。标记后不是直接清理可回收对象，而是让所有存活的对象都向内存的一端移动，然后直接清理掉边界以外的内存。解决了标记-清理算法产生内存碎片的问题。缺点：移动对象后需要更新引用，更新引用的操作需要暂停用户程序，即`Stop The World`,代价高昂。

### 经典垃圾收集器

JDK7之后~JDK11之前可用的收集器，目前仍在应用。

**Serial收集器**： (serial,顺序的)； 最早的新生代收集器，采用标记-复制算法。单线程工作，进行垃圾收集时，必须暂停其他所有工作线程，直到收集结束，即传说中的`Stop The World`。优点：内存占用小，时当前HotSpot客户端模式下的默认新生代收集器。

**ParNew收集器**：Serial收集器的多线程版本，其他的几乎一致。

**Parallel Scavenge收集器**（parallel-平行的 ，scavenge-扫荡）：也叫`吞吐量优先收集器`,新生代收集器，多线程，采用标记-复制算法。特点：达到一个可控制的**吞吐量**，即处理器用于运行用户代码的时间与处理器总消耗时间的比值。适合后台运算较多交互较少的分析任务。根据设定的吞吐量自适应调节也是它的一个重要特性。

**Serial Old收集器**：Serial收集器的老年代版本。采用**标记-整理算法**，单线程工作。主要供客户端模式下使用，或CMS收集器发生失败时的后备预案。

**Parallel Old收集器**：Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于**标记-整理算法**实现。

※ **CMS收集器**：（Concurrent Mark Sweep），基于**标记-清除算法**,以获取最短回收停顿时间为目标的收集器，适用于B/S架构的多交互环境。

>CMS收集器的执行过程：
>
>1. 初始标记（CMS initial mark）
>2. 并发标记（CMS concurrent mark）
>3. 重新标记（CMS remark）
>4. 并发清除（CMS concurrent sweep）

