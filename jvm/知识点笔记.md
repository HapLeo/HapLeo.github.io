#### 为什么要学习JVM?
了解JVM特性和运行原理，才能写出最适合JVM运行的代码；

学习JVM的知识模块：自动内存管理、编译与优化、并发。



#### 内存管理

JVM的运行时数据区如何划分？

JVM运行时数据区分为五个部分：方法区、堆区、虚拟机栈、本地方法栈、程序计数器。其中，方法区和堆区是线程共享区域，虚拟机栈、本地方法栈、程序计数器则为线程私有区域。

**程序计数器**：线程私有，存放下一条字节码指令的行号，用于分支循环等流程控制、跳转、异常处理、线程恢复等。

**虚拟机栈**：线程私有，一个线程每调用一个方法，就会生成一个栈帧进入虚拟机栈，栈帧保存了方法的局部变量表、操作数栈、动态连接、方法出口等信息；方法调用完毕该栈帧就会出栈。

> 什么是局部变量表？局部变量表存放了编译期可知的基本数据类型的变量、对象引用和返回类型。
>
> 虚拟机栈会抛出什么异常？每个线程占用一块虚拟机栈的空间，在一个线程里，不停地调用方法，就会不停地产生栈帧并压入栈，当栈帧过多时就会抛出StackOverFlowError；如果虚拟机栈容量可以自动扩展，那么它会一直变大，直到申请不到内存了，就会抛出OutOfMemoryError.

**本地方法栈**：线程私有，与本地方法栈类似，转为native方法服务。

> Hotspot中对虚拟机栈与本地方法栈进行了合并。

**Java堆**：线程共享，唯一的目的就是存放对象实例，几乎所有对象实例都在这里分配内存。

> 通过参数 -Xmx和-Xms设定堆的最大内存和初始内存。
>
> 如果堆的内存耗尽，且无法扩展时，JVM抛出OutOfMemeryError异常；

**方法区**：线程共享，存放已经被虚拟机加载的类型信息、常亮、静态变量、即时编译器编译后的代码等。

> 方法区无法满足新的内存分配需求时，抛出OutOfMemoryError异常；

**运行时常量池**：方法区的一部分，用于存放编译期生成的各种字面量与符号引用，也可运行期间放入新的常量，常用的例子：`String.intern()`;

**直接内存**：NIO通过Channel和Buffer方式调用Native函数直接分配堆外内存以提高性能，这部分内存不受-Xmx限制，但如果本机内存不足以分配新的堆外内存，会抛出OutOfMemoryError异常。



HotSpot中对象在堆中的创建过程是怎样的？

JVM遇到一条字节码的new指令时：

1. **加载类**：先去常量池中找对应的符号引用，并检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，就进行类的加载；
2. **分配内存**：内存大小在类加载完成后即可确定。为对象分配内存有两种方式：`指针碰撞`和`空闲列表`，指针碰撞方式是指针沿着规整的内存移动与对象相等大小，适合带有压缩整理的GC；空闲列表方式是将空闲内存记录到一个列表中，为对象分配内存时到列表中找到大小最适合的内存块，这种方式适合基于清除算法的GC；

3. **初始化零值**：将分配到的内存除对象头以外全部初始化为零值，这也是Java中字段可以不赋初始值就可使用的原因。
4. **设置对象头**：对象头保存了该对象的多种信息：类型指针、哈希码、GC分代年龄、偏向锁等。
5. **执行构造函数**：执行Class文件中的`<init>()`方法,配置对象的资源和状态信息；

> 对象创建过程需要操作堆区和方法区，这两个区都是线程共享的内存区域，如何保证线程安全？
>
> 两种方法：`CAS+失败重试`和`TLAB(Thread Local Allocation Buffer)`,其中TLAB会优先使用。

对象在内存中长什么样子？

对象可划分成三个部分：对象头、实例数据、对齐填充。

**对象头（Header）**：包含两部分：Mark word和类型指针。

`Mark Word`：32位机器中占32比特，64位机器中占64比特，保存了对象的哈希码、分代年龄、锁标志等信息。

`类型指针`：保存指向该对象的类型元数据的指针。如果是数组对象，还要保存数组长度。

**实例数据（Instance Data）**：记录父类和当前类的字段内容，默认分配顺序为：longs/doubles、ints、shorts/chars、bytes/booleans、oops(Ordinary Object Pointers,OOPs)。字段分配顺序可以归结为：`宽度优先，父类优先`，即比较宽的字段在前面，相同宽度的字段父类优先。

**对齐填充（Padding）**：HotSpot要求对象起始地址必须是8字节的整数倍，因此，如果对象头和实例数据占用内存不是8字节整数倍，需要对齐填充来补全。

对象创建好后，如何找到它？

虚拟机栈里，每个线程的栈帧中都保存着一个方法的本地变量表，变量表中存放着对象引用，这些引用保存了对象的内存地址或对象的句柄的内存地址。

>  保存地址和保存句柄有什么区别？如果引用保存着对象的地址，当对象被GC移动后，需要修改引用中的地址，而如果保存对象的句柄，则GC移动后只需要修改句柄中的地址即可，引用可以保持不变。使用句柄的代价是多了一次跳转的消耗。

哪些区会抛出OutOfMemoryError（OOM）异常？什么情况会导致抛出该异常？

理论上堆区、方法区、虚拟机栈、本地方法栈都会抛出OutOfMemoryError异常，只有程序计数器不会抛出异常。

堆区：堆区保存着对象实例，堆区大小通过参数：`-Xms`和`-Xmx`分别控制着最小值和最大值。当堆内存无法为新的对象分配内存时，会抛出OOM异常；因此，诊断堆区OOM异常原因时，首先要想到是否是某个引用导致大对象无法回收形成的内存泄漏，如果不是，则需要适当调大堆区内存。

> 自JDK1.7起，运行时常量池已经从方法区迁入堆区中，例如：`String.intern()`获取的是字符串对象在堆中的引用。因此，过多的运行时常量也有可能导致OOM异常。
>
> 通过参数：`+HeapDumpOnOutOfMemoryError`可以在JVM出现内存溢出时Dump出当前内存堆转储快照以便分析。堆内存的溢出通常会在OutOfMemoryError后面跟上说明：Java heap space.

方法区：方法区用来保存类的信息，如类名、访问修饰符、常量池、字段描述、方法描述等。当方法区的空间不足以加载新的类时，就会抛出OOM异常。

> 这样的场景包括：通过动态代理、CGLib、JSP之类的模板引擎等产生大量的类；
>
> JDK1.7及之前，HotSpot中使用永久代实现方法区，通过`-XX:PermSize`和`-XX:MaxPermSize`限制永久代大小；JDK1.8及之后，HotSpot中使用元空间实现方法区，通过`-XX:MetaspaceSize`指定初始大小，`-XX:MaxMetaspaceSize`指定最大值，该值默认为-1，即不限制，只受限于本地内存大小，因此很难出现方法区OOM异常了。参数`-XX:MinMetaspaceFreeRatio`，指定一个比例，当GC之后，元空间剩余空间比例不小于这个值；参数`-XX:MaxMetaspaceFreeRatio`控制元空间最大剩余比例。

虚拟机栈和本地方法栈：在HotSpot中并不区分虚拟机栈和本地方法栈。《Java虚拟机规范》中，如果线程请求的栈深度大于虚拟机允许的栈深度，将抛出StackOverFlowError异常；如果虚拟机栈内存允许动态扩展，则扩展到无法申请到足够内存时，抛出OOM异常。而HotSpot选择不支持扩展，所以只有在创建线程分配内存时无法获得足够内存而出现OOM，否则在线程运行时是不会出现OOM的，只会因为栈容量无法容纳新的栈帧而导致StackOverFlowError异常。

> 栈的容量通过参数：`-Xss`设定。

本机直接内存溢出：典型场景是使用NIO，此时Dump出的文件很小，OOM异常后面没有任何提示。

> 直接内存容量大小通过参数：`-XX:MaxDirectMemorySize`指定，默认与堆的最大值（`-Xmx`）一致。





## 垃圾回收器及内存分配策略

如何判断一个对象是否存活？

通常两种算法：引用计数法和可达性分析算法。

引用计数法：保存每个对象的当前引用个数。缺点：对象之间互相引用的问题。

可达性分析算法：通过根对象（GC Roots）作为起始节点集，从起始节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”。如果对象与GC Roots间没有任何引用链，即不可达，则此对象无法再被使用。

什么是强引用、软引用、弱引用、虚引用？

**强引用**（Strongly Reference）：普通的引用，如Object obj = new Object();只要强引用关系还在，垃圾收集器就不会这个对象。

**软引用**（Soft Reference）: 还有用，但非必须的对象，通过SoftReference类构造软引用；只被软引用关联着的对象，在系统将要发生内存溢出之前被二次回收，如果仍没有足够内存再抛出OOM异常。

**弱引用**（Week Reference）:关联的对象只能生存到下一次GC。通过WeekReference类构造弱引用。

**虚引用**（Phantom Reference）: 不会对关联的对象的生存时间产生任何影响，也无法通过虚引用取得对象实例。虚引用的目的是能在这个对象被回收时收到一个系统通知。通过PhantomReference构造虚引用。

当一个对象通过可达性分析第一次被发现没有与GC Roots连接的引用链时，并不会被直接回收，而是将其加入队列去执行finalize()方法，然后给这个对象标记下一次不需要执行finalize()方法。第二次发现它没有与GC Roots连接的引用链时，又发现了不需要执行finalize()方法的标记，则会进行回收。

### 分代收集理论

分代收集理论基于两个分代假说：

弱分代假说：绝大多数对象都是朝生夕灭的。

强分代假说：熬过越多次垃圾收集过程的对象越难以消亡。

因此，将收集器划分出不同的年龄区域，通过不同的算法进行高效回收。

**部分收集**（Partial GC）:指目标不是完整收集整个堆得垃圾收集。

**新生代收集**（Minor GC/Young GC）:指目标只是新生代的垃圾收集.

**老年代收集**(Major GC/Old GC):指目标只是老年代的垃圾收集。有些地方的Major GC代表整堆收集；

**混合收集**(Mixed GC):指目标是收集整个新生代以及部分老年代的垃圾收集。

**整堆收集**(Full GC):收集生个Java堆和方法区的垃圾收集。



### 垃圾收集算法

**标记-清除算法（Mark-Sweep）**：先标记，再清除。带来的问题：大量的标记和清除动作导致GC效率低；空间碎片问题。

**标记-复制算法**：将内存均分为两块，当一块内存用完了，就将还存活的对象复制到另一块上面，再把已使用过的内存空间一次清理掉，适合存活对象较少的场景。带来的问题：空间利用率低。

**Appel算法**：适用于新生代的算法。把新生代分为较大的Eden区和两块较小的Survivor区（Survivor1和Survivor2），每次分配内存只使用Eden和其中一块Survivor。发生垃圾收集时，将Eden区和Survivor区中仍然存活的对象放到另一块Survivor区中，并清理掉Eden区和那块Survivor。HotSpot中，Eden区占80%空间，Survivor1和Survivor2分别占10%空间。特殊情况，当Survivor空间不足以容纳一次Minor GC存活的对象时，就需要其他的内存区域（通常是方法区）进行分配担保。

**标记-整理算法（Mark-Compact）**：适用于老年代的算法。标记后不是直接清理可回收对象，而是让所有存活的对象都向内存的一端移动，然后直接清理掉边界以外的内存。解决了标记-清理算法产生内存碎片的问题。缺点：移动对象后需要更新引用，更新引用的操作需要暂停用户程序，即`Stop The World`,代价高昂。

### 经典垃圾收集器

JDK7之后~JDK11之前可用的收集器，目前仍在应用。

**Serial收集器**： (serial,顺序的)； 最早的新生代收集器，采用标记-复制算法。单线程工作，进行垃圾收集时，必须暂停其他所有工作线程，直到收集结束，即传说中的`Stop The World`。优点：内存占用小，时当前HotSpot客户端模式下的默认新生代收集器。

**ParNew收集器**：Serial收集器的多线程版本，其他的几乎一致。

**Parallel Scavenge收集器**（parallel-平行的 ，scavenge-扫荡）：也叫`吞吐量优先收集器`,新生代收集器，多线程，采用标记-复制算法。特点：达到一个可控制的**吞吐量**，即处理器用于运行用户代码的时间与处理器总消耗时间的比值。适合后台运算较多交互较少的分析任务。根据设定的吞吐量自适应调节也是它的一个重要特性。

**Serial Old收集器**：Serial收集器的老年代版本。采用**标记-整理算法**，单线程工作。主要供客户端模式下使用，或CMS收集器发生失败时的后备预案。

**Parallel Old收集器**：Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于**标记-整理算法**实现。

※ **CMS收集器**：（Concurrent Mark Sweep），也被称作“并发低停顿收集器”，是重要的老年代垃圾收集器，，基于**标记-清除算法**,以获取最短回收停顿时间为目标的收集器，适用于B/S架构的多交互环境。

>CMS收集器的执行过程：
>
>1. 初始标记（CMS initial mark）: 需要stop the world,仅仅标记一下GC Roots能直接关联到的对象，速度很快；
>2. 并发标记（CMS concurrent mark）:从GC Roots的直接关联对象开始遍历整个对象图的过程，耗时较长但不需要暂停用户线程；
>3. 重新标记（CMS remark）:重新标记为了修正并发标记期间用户线程运行导致的标记变动，需要stop the world；
>4. 并发清除（CMS concurrent sweep）:删除掉已标记死亡的对象，由于不需要移动存活对象，所以可以与用户线程并发执行。

CMS的缺点：

- 并发时占用一部分CPU核心，降低用户程序的吞吐量，在四核以下处理器时更为明显；

- 因为基于`标记-清除算法`会出现空间碎片化，因此需要在一次或几次（可配置）Full GC之后，进行一次碎片整理。

- **浮动垃圾**导致Full GC。由于并发标记和并发清除阶段用户线程不暂停，垃圾仍会不断产生，这部分垃圾会在下次收集时再清理，这些垃圾叫做浮动垃圾。当老年代使用的空间达到阈值时，CMS被激活，如果阈值过高，导致无法分配新的对象则会出现一次“并发失败”（Concurrent Mode Failure），这时候会冻结用户线程并临时启用Serial Old收集器进行老年代垃圾收集，从而导致停顿时间过长。

  > CMS触发垃圾收集的阈值通过参数：`-XX:CMSInitiatingOccu-pancyFraction`设置；

**G1收集器**：里程碑式的成果，开创了收集器面向局部收集的设计思路和基于Region的内存布局形式，官方称之为“全功能垃圾收集器”，“全功能”意味着不再区分新生代、老年代、永久代。G1时Garbage First的缩写，意为优先处理回收价值收益最大的那些Region，这种方式保证了G1在有限的时间内获取尽可能的收集效率。

G1是面向服务端应用的垃圾收集器。JDK9中默认的垃圾收集器，替换掉CMS。

**停顿时间模型**：在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间大概率不超过N毫秒。

G1可以面向堆内存任何部分来组成回收集（Collection Set，简称CSet）进行回收。衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的Mixed GC模式。

G1不在支持固定大小及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每个Region都可以根据需要扮演Eden/Survivor或者老年代空间。

**Humongous Region**: 用于存储大对象的区域。只要对象大小超过了一个Region的一半大小，就称为大对象。超过整个Region的超级大对象会被存储于多个连续的Humongous Region中。Humongous Region被当做老年代看待。

G1保留了新生代和老年代的概念，但不再是固定的区域，而是一系列不必连续的动态集合。

> Region大小可以通过参数：`-XX:G1HeapRegionSize`设定，取值范围为1MB~32MB,且应为2的n次幂。
>
> 用户允许的收集停顿时间通过参数：`-XX:MaxGCPauseMillis`指定，默认值200毫秒。

G1收集器的运作过程：

**初始标记（Initial Marking）**:仅仅标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确的在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，且与Minor GC同步进行。

**并发标记（Concurrent Marking）**:alarm_clock: 从GC Roots开始对对中对象进行可达性分析，递归扫描整个堆的对象图，找出要回收的对象，耗时较长但可以与用户线程并发执行。对象图扫描完成后，需要重新处理SATB记录下的在并发时引用变动的对象。

**最终标记（Final Marking）**:stop_button: 对用户线程做短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后少量的SATB记录。

**筛选回收（Live Data Counting and Evacuation）**:负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户期望的停顿时间制定回收计划，选定回收的Region,把这些Region中的对象复制到空的Region中，清理旧Region空间，这里的对象搬移必须暂停用户线程，多条GC线程并行完成。因此，除了并发标记外，其余阶段都需要暂停用户线程。这体现了G1的设计思想并不是纯粹追求低延迟，而是在延迟可控的前提下，尽可能提高吞吐量。

注意：用户设置的停顿期望通常设置在两百左右，默认值也为两百毫秒，如果设置的过低，会导致停顿时间过短，收集的Region数量极少，垃圾收集的速度赶不上垃圾产生的速度进而导致Full GC,反而影响效率。

G1的几大特色：可指定期望停顿时间、Region内存布局、按收益确定回收集、算法更好。

> G1的算法优秀在于：整体来看基于`标记-整理`，局部来看基于`标记-复制`,不会产生内存碎片，不易触发大对象导致的下一次GC。

G1的缺点：内存占用和执行负载较高。

