#### 为什么要学习JVM?
了解JVM特性和运行原理，才能写出最适合JVM运行的代码；

学习JVM的知识模块：自动内存管理、编译与优化、并发。



#### 内存管理

JVM的运行时数据区如何划分？

JVM运行时数据区分为五个部分：方法区、堆区、虚拟机栈、本地方法栈、程序计数器。其中，方法区和堆区是线程共享区域，虚拟机栈、本地方法栈、程序计数器则为线程私有区域。

**程序计数器**：线程私有，存放下一条字节码指令的行号，用于分支循环等流程控制、跳转、异常处理、线程恢复等。

**虚拟机栈**：线程私有，一个线程每调用一个方法，就会生成一个栈帧进入虚拟机栈，栈帧保存了方法的局部变量表、操作数栈、动态连接、方法出口等信息；方法调用完毕该栈帧就会出栈。

> 什么是局部变量表？局部变量表存放了编译期可知的基本数据类型的变量、对象引用和返回类型。
>
> 虚拟机栈会抛出什么异常？每个线程占用一块虚拟机栈的空间，在一个线程里，不停地调用方法，就会不停地产生栈帧并压入栈，当栈帧过多时就会抛出StackOverFlowError；如果虚拟机栈容量可以自动扩展，那么它会一直变大，直到申请不到内存了，就会抛出OutOfMemoryError.

**本地方法栈**：线程私有，与本地方法栈类似，转为native方法服务。

> Hotspot中对虚拟机栈与本地方法栈进行了合并。

**Java堆**：线程共享，唯一的目的就是存放对象实例，几乎所有对象实例都在这里分配内存。

> 通过参数 -Xmx和-Xms设定堆的最大内存和初始内存。
>
> 如果堆的内存耗尽，且无法扩展时，JVM抛出OutOfMemeryError异常；

**方法区**：线程共享，存放已经被虚拟机加载的类型信息、常亮、静态变量、即时编译器编译后的代码等。

> 方法区无法满足新的内存分配需求时，抛出OutOfMemoryError异常；

**运行时常量池**：方法区的一部分，用于存放编译期生成的各种字面量与符号引用，也可运行期间放入新的常量，常用的例子：`String.intern()`;

**直接内存**：NIO通过Channel和Buffer方式调用Native函数直接分配堆外内存以提高性能，这部分内存不受-Xmx限制，但如果本机内存不足以分配新的堆外内存，会抛出OutOfMemoryError异常。



HotSpot中对象在堆中的创建过程是怎样的？

JVM遇到一条字节码的new指令时：

1. **加载类**：先去常量池中找对应的符号引用，并检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，就进行类的加载；
2. **分配内存**：内存大小在类加载完成后即可确定。为对象分配内存有两种方式：`指针碰撞`和`空闲列表`，指针碰撞方式是指针沿着规整的内存移动与对象相等大小，适合带有压缩整理的GC；空闲列表方式是将空闲内存记录到一个列表中，为对象分配内存时到列表中找到大小最适合的内存块，这种方式适合基于清除算法的GC；

3. **初始化零值**：将分配到的内存除对象头以外全部初始化为零值，这也是Java中字段可以不赋初始值就可使用的原因。
4. **设置对象头**：对象头保存了该对象的多种信息：类型指针、哈希码、GC分代年龄、偏向锁等。
5. **执行构造函数**：执行Class文件中的`<init>()`方法,配置对象的资源和状态信息；

> 对象创建过程需要操作堆区和方法区，这两个区都是线程共享的内存区域，如何保证线程安全？
>
> 两种方法：`CAS+失败重试`和`TLAB(Thread Local Allocation Buffer)`,其中TLAB会优先使用。

对象在内存中长什么样子？

对象可划分成三个部分：对象头、实例数据、对齐填充。

**对象头（Header）**：包含两部分：Mark word和类型指针。

`Mark Word`：32位机器中占32比特，64位机器中占64比特，保存了对象的哈希码、分代年龄、锁标志等信息。

`类型指针`：保存指向该对象的类型元数据的指针。如果是数组对象，还要保存数组长度。

**实例数据（Instance Data）**：记录父类和当前类的字段内容，默认分配顺序为：longs/doubles、ints、shorts/chars、bytes/booleans、oops(Ordinary Object Pointers,OOPs)。字段分配顺序可以归结为：`宽度优先，父类优先`，即比较宽的字段在前面，相同宽度的字段父类优先。

**对齐填充（Padding）**：HotSpot要求对象起始地址必须是8字节的整数倍，因此，如果对象头和实例数据占用内存不是8字节整数倍，需要对齐填充来补全。

对象创建好后，如何找到它？

虚拟机栈里，每个线程的栈帧中都保存着一个方法的本地变量表，变量表中存放着对象引用，这些引用保存了对象的内存地址或对象的句柄的内存地址。

>  保存地址和保存句柄有什么区别？如果引用保存着对象的地址，当对象被GC移动后，需要修改引用中的地址，而如果保存对象的句柄，则GC移动后只需要修改句柄中的地址即可，引用可以保持不变。使用句柄的代价是多了一次跳转的消耗。

哪些区会抛出OutOfMemoryError（OOM）异常？什么情况会导致抛出该异常？

理论上堆区、方法区、虚拟机栈、本地方法栈都会抛出OutOfMemoryError异常，只有程序计数器不会抛出异常。

堆区：堆区保存着对象实例，堆区大小通过参数：`-Xms`和`-Xmx`分别控制着最小值和最大值。当堆内存无法为新的对象分配内存时，会抛出OOM异常；因此，诊断堆区OOM异常原因时，首先要想到是否是某个引用导致大对象无法回收形成的内存泄漏，如果不是，则需要适当调大堆区内存。

> 自JDK1.7起，运行时常量池已经从方法区迁入堆区中，例如：`String.intern()`获取的是字符串对象在堆中的引用。因此，过多的运行时常量也有可能导致OOM异常。
>
> 通过参数：`+HeapDumpOnOutOfMemoryError`可以在JVM出现内存溢出时Dump出当前内存堆转储快照以便分析。堆内存的溢出通常会在OutOfMemoryError后面跟上说明：Java heap space.

方法区：方法区用来保存类的信息，如类名、访问修饰符、常量池、字段描述、方法描述等。当方法区的空间不足以加载新的类时，就会抛出OOM异常。

> 这样的场景包括：通过动态代理、CGLib、JSP之类的模板引擎等产生大量的类；
>
> JDK1.7及之前，HotSpot中使用永久代实现方法区，通过`-XX:PermSize`和`-XX:MaxPermSize`限制永久代大小；JDK1.8及之后，HotSpot中使用元空间实现方法区，通过`-XX:MetaspaceSize`指定初始大小，`-XX:MaxMetaspaceSize`指定最大值，该值默认为-1，即不限制，只受限于本地内存大小，因此很难出现方法区OOM异常了。参数`-XX:MinMetaspaceFreeRatio`，指定一个比例，当GC之后，元空间剩余空间比例不小于这个值；参数`-XX:MaxMetaspaceFreeRatio`控制元空间最大剩余比例。

虚拟机栈和本地方法栈：在HotSpot中并不区分虚拟机栈和本地方法栈。《Java虚拟机规范》中，如果线程请求的栈深度大于虚拟机允许的栈深度，将抛出StackOverFlowError异常；如果虚拟机栈内存允许动态扩展，则扩展到无法申请到足够内存时，抛出OOM异常。而HotSpot选择不支持扩展，所以只有在创建线程分配内存时无法获得足够内存而出现OOM，否则在线程运行时是不会出现OOM的，只会因为栈容量无法容纳新的栈帧而导致StackOverFlowError异常。

> 栈的容量通过参数：`-Xss`设定。

本机直接内存溢出：典型场景是使用NIO，此时Dump出的文件很小，OOM异常后面没有任何提示。

> 直接内存容量大小通过参数：`-XX:MaxDirectMemorySize`指定，默认与堆的最大值（`-Xmx`）一致。